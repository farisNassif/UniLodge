\chapter{Technology Review}
Over the course of the project life cycle a plethora of frameworks, tools and development applications were available for integration or use with our application. This section aims to discuss the tools and technologies that were heavily considered and those that were ultimately used, why they were chosen and what alternatives were available. 

\section{Initial Considerations}
During the discussion and planning phase goals were outlined and proposed however, how to reach the end point was still very ambiguous. For this reason a lot of time was spent considering different approaches and uncovering the benefits and drawbacks of venturing down a chosen route. This brief section will outline those initially considered approaches.
\subsection{MEAN Stack}
The MEAN Stack combines the best of JavaScript based technologies. The Stack is essentially a collection of open source components that provide a streamlined environment for building dynamic web applications. 

\paragraph{}
The MEAN Stack consists of:

\begin{description}
  \item[$\bullet$] MongoDB
  \item[$\bullet$] ExpressJS
  \item[$\bullet$] Angular
  \item[$\bullet$] Node.js
\end{description}

\paragraph{}
Perhaps the greatest attribute of the MEAN Stack for developers is that it's essentially a single language development stack, which can also be one of it's most undesirable attributes depending on the developers JavaScript competency \cite{MEAN_STACK}. Other attributes that the development team considered attractive were the vast array of libraries and modules exposed via Node, it's speed, usability and flexible structure. 

\paragraph{}
Another technology stack that piqued the attention of the developers was the MERN Stack, which is essentially the MEAN Stack excluding Angular and including React. Research was conducted on comparing the two \cite{MEAN_STACK_vs_MERN_STACK} and the following was found:

\begin{table}[htp]
\begin{tabularx}{\linewidth}{>{\parskip1ex}X@{\kern4\tabcolsep}>{\parskip1ex}X}
\toprule
\hfil\bfseries Angular
&
\hfil\bfseries React
\\\cmidrule(r{3\tabcolsep}){1-1}\cmidrule(l{-\tabcolsep}){2-2}

%% PROS, seperated by empty line or \par
\begin{compactitem}[-]
\item[+] Testing tools like Jasmine and Karma are well documented Angular frameworks that allow for seamless human-readable Unit Tests or browser/platform based test cases.
\item[+] Application logic is a lot clearer and less convoluted than React due to it's declarative nature.
\item[+] Enforces MVC-like design, giving developers an underlying structure to adhere to. React applications can be harder to maintain considering the overall design can be ambiguous and more unstructured.
\item[+] Unidirectional data flow in applications allow data to flow to more seamlessly check for a change of state.
\item[$-$] Weak ability to debug code. Debugging can be ambiguous without manual inclusion of libraries.
\end{compactitem}
\par

&

%% CONS, seperated by empty line or \par
\begin{compactitem}[-]
\item[+] Mastering React is a lot less punishing than delving into Angular, Angular being a complete framework that incorporates associated knowledge of concepts like MVC or familiarity with Typescript.
\item[+] Unidirectional data flow in applications allow data to flow to more seamlessly check for a change of state.
\item[+] Very lightweight and less cumbersome than Angular for setup and collaboration. Dependency control is managed automatically.
\item[$-$] Relies heavily on third-party libraries for actions and tasks that Angular could perform by on the fly due to it's built in service wrappers like for example Angular's built in wrappers for HTTP calls to the backend. 
\end{compactitem}

\\\bottomrule
\end{tabularx}
\caption{Advantages and Disadvantages of React \& Angular}
\end{table}

\subsection{VueJS}
VueJS is a JavaScript based framework used for building user interfaces and single page applications that can integrate seamlessly into a project at any stage. VueJS is marketed as an approachable, versatile and performant framework, boasting an incrementally adoptable system that's scaleable between a fully featured framework and a library \cite{VUE}. However a major downfall of the framework is considered to be it's steep learning curve. VueJS was trialed for two weeks by the team, and following supervisory meetings and discussions between team members, the team ultimately decided due to the steep learning curve, the intimidating documentation for beginners and lack of tutorials that it wouldn't see a place in the development stack.

\subsection{Redis}
Redis, meaning REmote DIctionary Server is an in-memory distributed key-value data-store. Redis supports multiple types of data structures including, streams, bitmaps, sets and spatial indexes to name a few \cite{REDIS_IO}. Key value databases excel at providing rapid access to information that has a corresponding function and following research and discussions with supervisors Redis was initially a very attractive inclusion into the project. The use of in-memory storage offers a number of advantages, namely data retrieval which as mentioned previously is extremely fast as well as memory writing being performed in mono-thread allows the write to be isolated, avoiding data loss \cite{REDIS}.

\paragraph{}
At early stages in the project, various machine learning implementations were being considered. Redis would have been a perfect inclusion should the project have adopted artificial intelligence in any form, allowing for rapid access and storage of short-lived large scale machine learning data.

\section{Chosen Technologies}
Following research, input from supervisors and trials of the aforementioned technologies, a stack was constructed that the developers felt would fit both the objective and scope of the project. This section will outline the technologies, tools, languages, frameworks and concepts that were ultimately implemented and descriptions of relevant implementations will be illustrated at a conceptual level.

\subsection{Angular}
\subsection{The Flask Micro-framework}
\subsection{MongoDB}
\subsection{ExpressJS / Node}

\section{Deployment}
\subsection{Heroku}
Heroku is an open source cloud application platform, providing extensive and well developed services for many aspects of the deployment life-cycle \cite{HEROKU}. Heroku boasts deployment simplicity, allowing the deployment of almost every type of application. Should the type of application not be supported, there are various official and third-party build-packs to allow for seamless deployment. Additionally, Heroku also supports deployment via Git, a very attractive feature considering the Version Control setup of the project.

\paragraph{}
Initially AWS had been the likely deployment platform for the application. While hands-on experience with AWS would be beneficial, the team ultimately decided to deploy the application via Heroku. Supervisory discussions and research into Heroku's different build-pack and deployment options made Heroku the clear front runner considering the nature of the developed project. The documentation is also extensive and very well written, allowing the team to save valuable time with deployment while still getting hands-on experience with a widely used cloud application platform.

\subsection{Honcho}
Honcho is a Python port of Foreman, a tool for managing procfile-based applications \cite{HONCHO}. Honcho's purpose is to abstract away any complications of the procfile format and allow the application to be either deployed directly or export it to some other process management format. Another benefit of Honcho in this context and the main reason it was employed is down to it's utility of allowing multiple processes to run in unison.

\begin{figure}[H]
    \centering
    \textbf{python: gunicorn runner:app -b 0.0.0.0:8087\\ node: npm install \&\& npm start -b 0.0.0.0:8081}
    \caption{Honcho Procfile}
    \label{image:honchoProcfile}
\end{figure}

\paragraph{}
Honcho allows a procfile to be defined (\textit{As outlined in \textbf{Fig.\ref{image:honchoProcfile}}}) in such a way that permits the specification of multiple processes to be ran on the cloud without employing additional Dyno workers, in this case, both the Python server for the API and the Express server to serve the static files can be ran in unison without any additional workers. The port must also be specified otherwise Heroku will assign a random port number to run on.

\begin{figure}[H]
    \centering
    \textbf{web: honcho -f ProcfileHoncho start}
    \caption{Heroku Procfile}
    \label{image:herokuProcfile}
\end{figure}

The Heroku procfile (\textit{As outlined in \textbf{Fig.\ref{image:herokuProcfile}}}) consists of a single line that starts the Honcho procfile, it acts as a type of necessary procfile proxy, since the contents of the Honcho procfile wouldn't run correctly in this procfile, it points Heroku to the Honcho procfile.

\begin{center}

\end{center}





\subsection{Ngrok}
